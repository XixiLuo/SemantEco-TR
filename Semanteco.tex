\documentclass[letterpaper]{report}
\usepackage{fullpage}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{url}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{hypcap}
\begin{document}
\title{SemantEco: A Modular Framework for Integration of Ecological, Environmental, and Earth Sciences Data}
\author{Evan W. Patton \\
Tetherless World Constellation\\
Rensselaer Polytechnic Institute\\
110 8th Street\\
Troy, NY 12180, USA\\
\texttt{pattoe@rpi.edu}
\and Patrice Seyed \\
University of New Mexico\\
1 University Boulevard\\
Albuquerque, NM 87131, USA\\
\texttt{seyeda2@rpi.edu}
\and Deborah L. McGuinness\\
Tetherless World Constellation\\
Rensselaer Polytechnic Institute\\
110 8th Street\\
Troy, NY 12180, USA\\
\texttt{dlm@cs.rpi.edu}
}
\maketitle
\begin{abstract}
In this paper we discuss the architecture of SemantEco, a modular framework for integrating data from ecological, environmental, and Earth sciences. The architecture of SemantEco encapsulates features as modules that can be combined to present data in different ways. We provide an in-depth discussion on module implementation as well as detail the existing modules available in SemantEco and how they interact with one another. The architecture is generalizable to other domains as well. % crap, I know
\end{abstract}

\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
The Tetherless World Constellation is supported in part by Fujitsu, Lockheed Martin, LGS, Microsoft Research, Qualcomm, in addition to sponsored research from DARPA, IARPA, NASA, NSF, and USGS. Evan W. Patton is supported by an NSF Graduate Research Fellowship.
\end{abstract}

\renewcommand{\abstractname}{Licensing}
\begin{abstract}
SemantEco is made available under the {\color{red} Apache License v2.0}. This documentation is made available under the terms of {\color{red} Creative Commons BY-SA 3.0 Unported License}.
\end{abstract}

\tableofcontents

\cleardoublepage
\addcontentsline{toc}{chapter}{\listfigurename}
\listoffigures

\cleardoublepage
\addcontentsline{toc}{chapter}{\listtablename}
\listoftables

\chapter{Introduction}
\label{introduction}
% The following is taken verbatim from the introduction to the FGCS paper. It should be adapted as necessary to fit a tech report.
In many places around the world, wildlife and the habitats on which they depend are deteriorating. For instance, almost 40 percent of the United States' freshwater fish species are considered at risk or vulnerable to extinction according to~\cite{fish}. Aiming at preserving the environment and wildlife, scientists and resource managers have initiated various efforts to monitor ecological and environmental trends, investigate causes and possible effects of pollution, and identify threats to wildlife and their habitats. To be effective, these efforts must be undertaken with a large scale and multidisciplinary perspective.  However, by nature this approach requires access and use of disparate data sources and systems. For example, the USGS provides integrated science and technology to support resource managers in the U.S. Department of the Interior (DOI) through initiatives such as the Wyoming Landscape Conservation Initiative (WLCI): an effort to assess and enhance aquatic and terrestrial habitats at a landscape scale in southwest Wyoming. Decision support systems are one end result of scientific research that facilitates examination of the many tradeoffs and conflicting drivers that resource managers often wade through in their work, from energy and agricultural development to fish and wildlife conservation to recreational uses of public lands. 

Meanwhile, semantic science and technologies have been used in environmental monitoring to facilitate knowledge encoding, data integration and collaborative scientific workflows~\cite{environmental-modelling}. Previously we proposed the Tetherless World Constellation Semantic Ecology and Environment Portal (SemantEco) \cite{SemantAqua:ISWC2011,SemantAqua:Wang-MSThesis} as both an environmental portal application and as an example of a semantic infrastructure for environmental informatics applications. The portal captures the semantics of domain knowledge using a family of ontologies, integrates environmental data (e.g. water quality measurement and regulatory data), infers pollution events using OWL2 inference, and leverages provenance. In this paper, we extend the focus of SemantEco beyond water quality and related human health effects to a more comprehensive effort that includes fish and wildlife species and their related health effects. As such, this extension is in concert with the “One Health” concept, defined as ``the collaborative effort of multiple disciplines — working locally, nationally, and globally — to attain optimal health for people, animals and the environment'' \cite{one-health}. Consider a data manager interested in identifying correlations between declines of a bird population observed in a river due to chemicals released by nearby factories. There may be direct causal links (i.e. pollutant X in a diet kills Y) or indirect links (e.g. pollutant X causes reproductive system changes leading to lowered breeding success and resultant population declines). To identify these scenarios, resource managers need access to a number and variety of information and data sources including databases containing species observation counts, literature on the environmental effects of pollutants, how species may migrate and interact with one another, and so forth. Semantic technologies will facilitate access to multidisciplinary information that will aid resource managers in making decisions about complex ecosystems. These technologies also enhance reusability and address extensibility issues targeting challenges in the areas of data integration, provenance, and scalability.

We use semantic technologies to provide responses to these challenges. This work presents a new architecture that evolves an existing water quality portal into a general model for performing ecological and environmental data integration across many different data sources and domains. Additionally, this new architecture is designed to be horizontally scalable through the use of representational state transfer \cite{REST}. We also demonstrate how semantic technologies can be used to encourage interoperability by connecting one existing well-used observation schema - the Extensible Observation Ontology (OBOE) \cite{OBOE} to support interoperable observation data. We investigated the reasoning implications of adopting OBOE for interpreting data and found out that OBOE brings greater interoperability at the cost of longer reasoning time. Additionally, we now integrate various ecological and environmental data: wildlife observational data from the Avian Knowledge Network (AKN\footnote{http://www.avianknowledge.net/}) and U.S. Geological Survey (USGS\footnote{http://www.usgs.gov/}); environmental criteria for wildlife from the Environmental Protection Agency (EPA\footnote{http://www.epa.gov/}); water body data from USGS; and health effects of contaminants on wildlife from Wildpro\footnote{http://wildpro.twycrosszoo.org/}. These are provided in addition to the existing water quality and regulatory data presented in earlier versions of this work. Our approach provides a formal encoding of the semantics of the data and provides services for automatic reasoning and visualizations. Furthermore, we compared the performance of a standard semantic web reasoner used in previous iterations with a new, customized rule based reasoner over our data. Lastly, we enhanced the provenance support of the existing portal by incorporating rationale as provenance. This extensibility enabled by semantic technologies allows the portal to consume data from many different domains and present it together for the purposes of informing environmental stakeholders.

\section{Definitions}
SemantEco is an amalgamation of many different ontologies and as such this technical report includes a number of detailed items. This section provides a number of definitions for common terms that readers will encounter throughout this document.

\begin{itemize}
\item SemantEco Framework - the conceptualization of SemantEco as a modular framework that combines different modules into a single application
\item SemantEco servlet - a Java Servlet 3.0 Specification-compatible servlet that implements the SemantEco Framework
\item jQuery - An extensible JavaScript library that provides powerful features for web application developers
\item AJAX - Asynchronous Javascript and XML, a process by which web applications make calls to a server to obtain data while the user can continue to interact with the current web page
\item BBQ - jQuery Back button and Query library; useful for providing navigation and state features in single-page web applications
\end{itemize}

\section{Where To Begin}
Readers interested in getting a general overview of how SemantEco is structured architectural should be able to read this document in order. Chapters are arranged such that having an understanding of earlier chapters provides a general background for future chapters. For readers interested in the application flow from a server perspective, Section \ref{servlet} introduces the SemantEco servlet and how it is initialized server side. For readers interested in the client-side application flow, Section \ref{index.jsp} introduces the SemantEco interface described in its index.jsp and walks through how it and the other user interface components operate.

\chapter{Architecture Design}
\label{architecture}
In this chapter we will discuss the architecture of the new SemantEco, from its adherence to the Java Servlet Specification so that it can be deployed in many different environments to its method of executing modules and queries to accomplish user tasks. We will also discuss how the RESTful client-server communication works to enable SemantEco both as a web application and as a web service.

\section{The SemantEco Servlet}
\label{servlet}
SemantEco is, at its core, a Java Servlet 3.0\footnote{http://jcp.org/aboutJava/communityprocess/final/jsr315/index.html} servlet. As such, it can be deployed into a number of servlet containers, such as Tomcat,\footnote{http://tomcat.apache.org/} Jetty,\footnote{http://jetty.codehaus.org/jetty/} and Glassfish.\footnote{http://glassfish.java.net/} In this way, system administrators can easily deploy SemantEco alongside existing servlet-based services and reduce overall system maintenance. Previous versions of SemantEco used a built-in HTTP server and were thus less flexible for deployment as it would need to be proxied through a forward-facing web server such as Apache.\footnote{http://httpd.apache.org/}. While proxying is no longer necessary, it can still be beneficial for deployments where speed is important as a proxy can cache SemantEco's responses.

The SemantEco servlet is, at its core, a `plug-and-play' architecture. The servlet mostly provides glue code that is responsible for combining functionality of different modules. A \textit{module} is a self-contained Java Archive that provides functionality to SemantEco via different methods. The specifics of how modules work will be discussed in Chapter~\ref{writing-modules}.

\subsection{Initialization of SemantEco on Deployment} 
When the servlet container starts or when a developer uses the maven tomcat7:deploy goal, the first action taken after the SemantEcoServlet is constructed is a call by the container to the init method per the Java Servlet 3.0 specification. During this initialization, SemantEco configures any missing directories, initializes its logging system (log4j), and sets up the module manager, which includes loading all prepackaged modules in the Web archive (war) file.

\subsection{Special URL Patterns}
\label{url-patterns}
The SemantEco responds to a number of URL patterns that require custom processing. These include:
\begin{itemize}
\item \texttt{/js/config.js} -- Client configuration specific to the SemantEco deployment, including the base URL for the deployment and where to submit RESTful calls.
\item \texttt{/js/modules/*} -- Autogenerated JavaScript files to facilitate client-server communication (see Section~\ref{client-server-comm}).
\item \texttt{/log} -- WebSockets interface for sending debugging data to client.\footnote{As of this writing there is no standardization for WebSockets in Java Servlet 3.0 so this functionality is limited to Tomcat 7+ servers that support HTTP Protocol upgrades via Apache Coyote.}
\item \texttt{/rest/*} -- RESTful calls to SemantEco modules (see Section~\ref{client-server-comm}).
\end{itemize}

\noindent If a request is made to the servlet, these special URLs are handled in the servlet's \texttt{doGet} method. Otherwise, the servlet container will attempt to retrieve the file named by the URL. If no such file exists than an HTTP 404 error will be generated.

\section{The Module Manager}
\label{module-manager}
SemantEco modules are maintained by a class called the \texttt{ModuleManager}. The \texttt{ModuleManager} is responsible for loading modules from their JAR files and configuring them. If a module is removed from SemantEco, the \texttt{ModuleManager} will delete the module instance and unload the module files from the class path. The \texttt{ModuleManager} is also responsible for constructing the user interface and semantic models and modifying queries before they are executed. It accomplishes these tasks by consulting the available modules.

\subsection{Installing Modules}
\label{installing-modules}
\texttt{ModuleManager} uses the Apache Virtual File System\footnote{http://commons.apache.org/vfs/} to actively monitor the modules directory and respond to the addition or deletion of modules. During servlet initialization, the \texttt{ModuleManager} will actively scan the directory and fire addition events for each module available at that time to bootstrap the entire process. When a module is added the following steps occur:

\begin{enumerate}
\item The \texttt{ModuleManager} instantiates a \texttt{ModuleClassLoader} object responsible for reading in the JAR file and defining the classes in the JAR with the Java Virtual Machine. It also performs validation that at least one of the classes in the JAR represents a implementation of the \texttt{Module} interface.
\item The \texttt{ModuleManager} `explodes' the JAR by extracting everything in the META-INF/res/ directory into the web application's resources directory under a module-specific directory to prevent naming clashes between modules. This directory is named the same as the JAR without the `.jar' extension.
\item The \texttt{ModuleManager} instantiates an instance of each \texttt{Module} implementation found in the jar.
\item The \texttt{ModuleManager} installs the newly created \texttt{Module} to its internal store.
\item The \texttt{ModuleManager} instantiates a \texttt{ModuleConfiguration} for each new module and loads the modules.properties file into the configuration for the module if one exists. This configuration is then supplied to the module via its \texttt{setModuleConfiguration} method.
\end{enumerate}

If during the initialization process an error occurs while processing the JAR's classes the module will not be instantiated and the \texttt{ModuleClassLoader} will be destroyed. If the module throws an exception in its constructor, then it will not be added to the list of available modules, \textbf{\textit{but its code will not be unloaded}}.

\subsection{Uninstalling Modules}
If a module is not needed or is acting faulty it can be removed from the system. When the module's JAR file is removed from the modules directory, the Apache Virtual File System will send the \texttt{ModuleManager} a message that the file has been removed, in which case the following steps occur:

\begin{enumerate}
\item 
\end{enumerate}

\subsection{Visiting Modules}

\section{ModuleConfiguration}
When each module is instantiated by the \texttt{ModuleManager}, the \texttt{ModuleManager} passes the module an instance of \texttt{ModuleConfiguration} via the module's \texttt{setModuleConfiguration} method. Modules that wish to execute queries or retrieve runtime information about available domains, etc., should save the reference to the \texttt{ModuleConfiguration} object.

The \texttt{ModuleConfiguration} object provides a number of useful methods for the module:

\begin{itemize}
\item\textbf{getSparqlEndpoint} - Retrieves the default SPARQL endpoint that will execute queries for this module. This can be overridden by calling a \texttt{QueryFactory}'s \texttt{execute} method that takes an endpoint URL.
\item\textbf{getQueryFactory} - Obtains a \texttt{QueryFactory} the module can use to instantiate \texttt{Query} objects.
\item\textbf{getQueryExecutor} - Obtains a \texttt{QueryExecutor} the module can use for executing queries either on remote endpoints (such as the default endpoint returned by getSparqlEndpoint) or the local model after all modules have populated it with content relevant to the actively processed \texttt{Request} object. The \texttt{QueryExecutor} object is discussed in more detail in Section~\ref{query-executor}.
\item\textbf{getResource} - Obtains a reference to a resource in the module's \texttt{META-INF/res} directory so that it can be added to the user interface.
\item\textbf{generateStringResource} - Generates a resource object from a string; this is primarily used for generating dynamic content based on SPARQL queries.
\item\textbf{getLogger} - Gets the default Apache log4j\footnote{http://logging.apache.org/log4j/1.2/} Logger for the module.
\item\textbf{getDomain} - Gets or creates a \texttt{Domain} object for a given URI; this should only be called by modules that also implement \texttt{ProvidesDomain} (note: SemantEco does not enforce this but interaction with domains are limited if a module is not also an implementation of \texttt{ProvidesDomain}).
\item\textbf{listDomains} - Returns a \texttt{java.util.List} of all domains know to SemantEco at the time it is called.
\end{itemize}

\section{The Query Executor}
\label{query-executor}
The \texttt{QueryExecutor} interface provides the primary method for modules to query the SemantEco knowledge base and interact with external SPARQL services via the Query object. It also provides methods for properly forming HTTP requests to external services to ease in module development by hiding many of the details related to calling remote services. Each QueryExecutor implementation must implement the following public methods:

\begin{itemize}
\item execute(Query) - Executes the specified query against the default endpoint and returns the response as a String.
\item execute(Query, Model) - Executes the specified query against the default endpoint and loads the response into the provided Jena model. This method only is valid for Query objects that are of type CONSTRUCT or DESCRIBE and thus return an RDF graph.
\item execute(String, Query) - Executes the specified query against the specified endpoint and returns the response as a String.
\item execute(String, Query, Model) - Executes the specified query against the specified endpoint and loads the response into the provided Jena model. The conditions on execute(Query, Model) also apply here.
\item getDefaultSparqlEndpoint() - Returns the default SPARQL endpoint. This will either be the SemantEco default or the module specific endpoint specified in the module's properties file (see subsection~\ref{installing-modules}).
\item accept(String) - Adds a MIME type to the Accept HTTP header, e.g. "application/json" or "text/turtle". This returns a clone of the QueryExecutor with appropriate modifications so that calls can be chained together to add multiple types and immediately perform an execution.
\item executeLocalQuery(Query) - Performs a local query over the knowledge base by obtaining the combined model via the current Request object (see subsection~\ref{request-object}).
\end{itemize}

For most modules, the general flow of information involving the \texttt{QueryExecutor} proceeds in the following way:

\begin{enumerate}
\item Construct a \texttt{Query} object and add appropriate triple patterns.
\item If the query is a CONSTRUCT or DESCRIBE query, construct a Jena \texttt{Model} object via Jena's \texttt{ModelFactory}.
\item Set the appropriate accept header using \texttt{accept()} and then call the appropriate execute method, e.g. \texttt{config.getQueryExecutor().accept("application/json").execute(myQuery);}
\end{enumerate}

Prior to execution of a query, the \texttt{QueryExecutor} calls the \texttt{ModuleManager}'s \texttt{augmentQuery(Query, Request, Module)} method. This causes the \texttt{ModuleManager} to pass each \texttt{Module} the query object so that they may add any additional triple patterns based on the parameters passed in the current state (encapsulated within the \texttt{Request} object). Modules are visited in the order that they were instantiated by the \texttt{ModuleManager} when the servlet was initialized. The final \texttt{Module} parameter is used by the \texttt{ModuleManager} to ensure termination by preventing an infinite loop in the event a \texttt{Module} creates and executes a \texttt{Query} from within its own \texttt{visit(Query, Request)} method---it is assumed that a \texttt{Module} has done everything it needs to do to construct the query prior to executing it.

\section{Client-Server Communication}
\label{client-server-comm}
In this section we will discuss how SemantEco uses the \texttt{@QueryMethod} annotation in order to generate communication code between client and server. 

\subsection{Query Methods}
To facilitate interaction between SemantEco clients and the SemantEco server, the framework provides an annotation for module designers called \texttt{QueryMethod} that allows the designer to identify Java methods that should be callable from client-side code. For each module with at least one \texttt{QueryMethod}, the framework will provide a \texttt{<script>} element in index.jsp under the \texttt{/js/modules/} path mentioned in Section~\ref{url-patterns}. The browser will attempt to load this script from this URL, which prompts SemantEco to generate the necessary glue code to support the call. This operation is done in the JavaScript generator.

\subsubsection{The JavaScript Generator}
The JavaScript generator is a utility class that is responsible for standardizing the client-server communication code to limit potential errors on the part of module designers. Each module has its \texttt{QueryMethod}s exposed in exactly the same way and any requests to these methods from the clients are processed in exactly the same way by the SemantEco servlet. The general flow of the JavaScript generator is as follows:

\begin{enumerate}
\item Begin by generating an empty JavaScript object assigned to a variable with the same name as the Java class.
\item For a given module, use the Java Reflect API to obtain a list of all methods defined on the module.
\item For each method, examine its annotation set to determine if the method has the \texttt{QueryMethod} annotation.
\item If the method is annotated as a \texttt{QueryMethod}, add a key/value pair to the JavaScript object in \#1 where the key is the name of the method and the value is a function that takes a dictionary of arguments, a success function, and an optional error function and performs the following actions:
\begin{enumerate}
\item Extend the SemantEco state with any optional arguments given in the arguments parameter. If an argument appears in both the state and the arguments object, the value in the arguments is used.
\item Using jQuery, execute an Asynchronous JavaScript and XML (AJAX) to the server at a predetermined URL in the form of \texttt{/rest/<module-name>/<method-name>}.
\item Set the success and error handlers on the AJAX request so the appropriate functions are called when the request completes.
\end{enumerate}
\item If at least one method was a \texttt{QueryMethod} return the final object back to the servlet so it can be sent to the client, otherwise return nothing.
\end{enumerate}

\subsubsection{The Request Object}
\label{request-object}
When a \texttt{QueryMethod} is called from a client, it is intercepted by the SemantEco servlet's \texttt{doGet} method. This method identifies the request as a RESTful call to a module and proceeds to parse the parameters sent by the client into the appropriate types. This information is then encapsulated in a \texttt{Request} object that can be passed to the module/method combination identified in the URL. In addition to providing modules access to the parameters of a REST call, the \texttt{Request} object also provides the following methods:

\begin{itemize}
\item\textbf{getLogger} - Gets an Apache log4j Logger customized for the specific request if the client sent a valid identifier for a known WebSocket outbound channel (see Section~\ref{debugging-techniques} for more details).
\item\textbf{getModel} - Gets the \texttt{OntModel} containing all of the ontologies for every active module based on the \textbf{Request}'s parameters. If the \texttt{OntModel} has not yet been constructed, this will cause one to be created and the \texttt{ModuleManager} will call each active module's \texttt{visit(OntModel)} method.
\item\textbf{getDataModel} - Gets the \texttt{Model} containing all of the data for every active module based on the \textbf{Request}'s parameters. If the \texttt{Model} has not yet been constructed, this will cause one to be created and the \texttt{ModuleManager} will call each active module's \texttt{visit(Model)} method.
\item\textbf{getCombinedModel} - Gets a combined \texttt{Model} that contains the contents of both the ontology model and data model. If either model has yet to be built this will construct the missing models first following the steps above.
\end{itemize}

It is important to note that the results of each of the above methods caches its results until the processing of the \texttt{Request} completes, i.e. multiple calls to these methods will not incur any additional time penalties after the model is first built.

\section{Debugging Techniques}
\label{debugging-techniques}
This section discusses some of the debugging techniques that designers can use in the construction and debugging of modules.

\subsection{Web Sockets}
To ease debugging server behavior during client actions, SemantEco uses the Web Socket specification to open up a persistent connection between the client and server if the client supports it. This occurs during the client's initialization procedure. If the Web Socket initialization is successful, the SemantEco servlet stores a reference to the socket and sends back a hash of the socket's reference that the client stores in a cookie. In future requests, the servlet will attempt to read the cookie and, if the hash identifies an open socket, will use that socket to generate a \texttt{LoggerWrapper} object that wraps the \texttt{Request}'s default logger and sends copies of all log statements to the client. Log statements received on the client via the Web Socket are printed to the client's console. Messages may still be blocked if the log level on the server is too high for the type of log required (e.g. the developer wishes to see DEBUG messages but the server is configured for INFO and higher).

\subsection{Remote Java Debugging}
In addition to using a Logger object to log events as they occur, it is also useful for designers to step through code and examine variables to identify potential logic issues and correct them. Because SemantEco uses the Maven build system it is generally the case that Eclipse does not recognize it as a servlet. Therefore, debugging the servlet is a more involved process than general servlet development done entirely in Eclipse. To debug SemantEco one should do the following:

\begin{enumerate}
\item Start Tomcat with \texttt{./catalina.sh jpda start} rather than \texttt{./startup.sh}. This enables the Java Platform Debugger Architecture in Tomcat's Java Virtual Machine.
\item In Eclipse, create a new Debug configuration for the SemantEco web app.
\item Add a new \textit{Remote Java Application} configuration.
\item Optionally, check the option that this configuration be included in the ``Favorites'' list.
\item Press the ``Debug'' button to connect to the virtual machine running Tomcat.
\end{enumerate}

Now, as Tomcat executes SemantEco code it will cause Eclipse to stop at any breakpoints set by the developer.

\chapter{Semantic Model}
\label{semantic-model}
In this chapter, we will present an overview of SemantEco's ontology using OWL 2 \cite{OWL2}. Furthermore, we will discuss how one models regulation violations and how modules can make use of the Pellet \cite{Pellet} semantic web reason to write more robust queries using inference.
\section{Sites, Measurements, and Pollution}
\label{class-defs}
In this section we define the \textit{Site}, \textit{Measurement}, and \textit{PollutedSite} classes and their relationships to one another as well as external ontologies such as NASA's SWEET ontology.
\section{Modeling Regulation Violations}
\label{regulation-violation}
In this section we will guide the reader through examples of how to model subclasses of \textit{RegulationViolation} to take advantage of the existing semantic model and queries provided by various modules (e.g. the regulation module).
\section{Querying the Model}
\label{querying}
In this section we will instruct the reader how to make use of the semantic model to simplify queries.


\chapter{User Interface}
\label{user-interface}
In this chapter we will provide an overview of the different components in the SemantEco interface and how modules use them to provide users with tools for controlling data search.

\section{The Semantic Entry Point: index.jsp}
\label{index.jsp}
When a user opens SemantEco in her browser, the servlet container compiles and executes the Java Servlet Page (JS) index.jsp, which can be found in SemantEco's webapp directory. This file provides the primary interface for users to access data provided by the various SemantEco modules and it is automatically generated through the use of a tag library and the SemantEcoUI object constructed by the ModuleManager when it visits each of the available modules, which will be discussed in Section~\ref{facets}.

\subsection{The SemantEco Tag Library}
SemantEco provides a Java Servlet Page tag library that simplifies the generation of the main page by condensing references to the various scripts, stylesheets, and facets provided by the different modules into three separate tags: \texttt{<module:scripts />}, \texttt{<module:styles />}, and \texttt{<module:facets />}. The module namespace is explicitly defined by the Tag Library Description (TLD) \texttt{WEB-INF/semanteco.tld} in the web application. The implementations of the tag handlers for these tags are located in the \texttt{edu.rpi.tw.escience.semanteco.taglib} package. For a complete overview of JSP tag handlers see \cite{JSPTagHandlers}.

\subsubsection{The Scripts Tag}

\subsubsection{The Styles Tag}

\subsubsection{The Facets Tag}


\section{Map Interface}
\label{maps}
In this section we will discuss how SemantEco presents known sites on a map interface.
\section{Module Facets}
\label{facets}
In this section we will inform the reader of how modules expose facets to the user as well as how they can control what information from the facet is used during client-server communication.
\section{Hierarchical Search with JSTree}
\label{hierarchical-search}
In this section we will discuss how SemantEco modules can present hierarchical search facets using OWL ontologies.
\section{Charting with jqPlot}
\label{visualization}
In this section we will discuss the use of jqPlot to provide data visualizations for the user.
\chapter{Writing Modules}
\label{writing-modules}
In this chapter we will detail the process of writing a module for SemantEco so that interested parties can provide extensions that complement the existing modules.
\section{The ProvidesDomain Interface}
In this section we discuss how to declare new domains for SemantEco.
\section{Ontology Construction}
In this section we provide examples of classes that extend the SemantEco ontology as a basis for discussing how module designers can similarly extend the ontology to model new domains.
\section{Data Conversion}
In this section we provide instructions for converting data using CSV2RDF4LOD \cite{lebo2011producing} and include some sample enhancements from previous conversions.
\section{Visitor Methods}
\label{visitors}
In this section we present a detailed discussion of the different visitor methods that modules must provide.
\subsection{Adding client interfaces and behavior}
In this subsection we outline how to add scripts, stylesheets, and facets to the SemantEco user interface via the UI visitor.
\subsection{Populating the Data Model}
In this subsection we demonstrate how to read data from an external triple store into the local model so that it will be exposed to the other modules and available for any local queries.
\subsection{Extending the Ontology Model}
In this subsection we demonstrate how to extend the ontology model by reading in external ontologies using Jena \cite{Jena}.
\subsection{Augmenting Queries from other Modules}
In this subsection we discuss how to augment queries and use the metaquery methods exposed by the \texttt{Query} object to make decisions about what modifications, if any, should be performed.
\section{Exceptional Behavior}
In this section we discuss alternative behaviors for loading and querying data and the reasons why one might want to use them over the visitor methods outlined in the previous section.
\chapter{Available Modules}
In this chapter we will provide an in-depth look at the current set of modules for SemantEco and the different datasets and query methods they provide. We will also discuss the different classifications of modules (i.e. core, data provider, and query-altering).
\section{Core Modules}
This section will discuss the core modules that are required in the general flow of SemantEco. Removing any of these modules will break the user interface as it is currently engineered (although in many cases an alternative module could be supplied).
\subsection{Domain Module}
In this subsection we discuss the domain module's purpose.
\subsection{Data Source Module}
In this subsection we discuss the data source module's purpose.
\subsection{Regulation Module}
In this subsection we discuss the regulation module's purpose and query methods.
\subsection{Entity Type Module}
In this subsection we discuss the entity type module's purpose.
\subsection{Zip Code Module}
In this subsection we discuss the zip code module's purpose and query methods.
\subsection{Debugger Module}
In this subsection we discuss the debugger module and how module designers can use it to assist in debugging modules.
\section{Data Provider Modules}
In this section we discuss data provider modules and how they provide data and ontologies to SemantEco through the various visitor methods discussed in Section~\ref{visitors}.
\subsection{Water Data Provider}
In this subsection we discuss the water data provider, its ontologies, and its data sources.
\subsection{Air Data Provider}
In this subsection we discuss the air data provider, its ontologies, and its data sources.
\subsection{Species Data Provider}
In this subsection we discuss the species data provider, its ontologies, and its data sources. We also discuss its use of the hierarchical search facet to assist users in locating data.
\section{Query-modifying Modules}
In this section we discuss modules that do not provide additional data, but instead make use of the query visitor pattern to augment queries from other modules to restrict them to certain criteria.
\subsection{Time Module}
In this subsection we discuss the time module and how it modifies queries pertaining to measurements to limit them to certain time frames.
\subsection{Industry Module}
In this subsection we discuss the industry module and how it uses North American Industry Classification System (NAICS) to restrict queries regarding facilities to those facilities in a particular industry.
\subsection{Characteristic Module}
In this subsection we discuss the characteristic module and its ontology that merges ChEBI and SNOMED. Furthermore, we discuss the use of this ontology in a hierarchical search facet.
\chapter{Conclusions}
In this chapter we will present our conclusions.

\appendix
\chapter{Maven Build System}
SemantEco uses the Apache Maven\footnote{\url{http://maven.apache.org/}} build system to handle its build process. Each component of SemantEco is a module in a top-level Maven POM file. Development of stand-alone modules can reference the build artifacts via Tetherless World's Artifactory installation. To do so, one must put the following snippet in their module's pom.xml:

\begin{lstlisting}
<repositories>
  <repository>
    <id>tetherless</id>
    <url>https://orion.tw.rpi.edu/artifactory/libs-release</url>
  </repository>
</repositories>
\end{lstlisting}

\noindent Note: This step is not required if you have added your module to the existing SemantEco repository as this step has already been done in the root pom.xml.

\section{Build-time Profiles and Application Configuration}
SemantEco has two Maven profiles that control its build process. The default profile is for development purposes and is configured to deploy the SemantEco WAR file to a local servlet container instance. The development profile also includes the \texttt{Debugger} module that provides an alternate interface for testing SPARQL queries against Pellet-backed data models. The second profile is for production deployment. It is configured specifically for SemantEco deployment at the Tetherless World Constellation, so its parameters should be adjusted according to the environment where it is set to be deployed. To build a production version, one must tell Maven to activate it via the \texttt{-P} command line parameter (i.e. \texttt{mvn clean install -P production}).

Additionally, SemantEco has a number of properties that govern its behavior at run time. It reads these properties from a file called semanteco.properties. These properties come from the \texttt{<properties>} element in the webapp's pom.xml file. As of this writing, the current set of properties are:

\begin{itemize}
\item \textbf{debug} This is set by development mode and increases the amount of logging performed by the application for debugging purposes.
\item \textbf{triple-store} The default triple store to execute queries against. In development it points to \url{http://was.tw.rpi.edu/virtuoso/sparql} and in production points to \url{http://localhost:3003/}.
\item \textbf{baseUrl} The base URL is the user-facing path for SemantEco. It uses this to construct its RESTful URLs for client-server communication. This should not be present in development. The default for production is \url{http://aquarius.tw.rpi.edu/projects/semanteco/}.
\end{itemize}

In addition to these properties, SemantEco also consumes a single environment variable, \texttt{semantEcoRootPath}, that defaults to its location within the servlet container's webapps directory. This is used for SemantEco to generate logs, and changing it will change where the log files are stored.

\chapter{Source Code Management}
The original line of SemantEco software was developed and maintained at Google Code.\footnote{\url{http://code.google.com/p/swqp/}} Due to the success of the project and the large number of exploratory offshoots, it was necessary to move to a faster source code management system. To this end, SemantEco has been migrated to use the Git source code management tool to maintain its source history. The project is hosted via Github at \url{https://github.com/ewpatton/SemantEco} and maintains the entire history of the project, including the original Subversion repository from Google Code.

Parties interested in submitting code to SemantEco should use the Github application to fork the repository and submit pull requests back to the main repository. The main repository uses the Git Flow\footnote{\url{http://nvie.com/posts/a-successful-git-branching-model/}} development paradigm, so pull requests should point to a branch from \texttt{develop} that contains the necessary code for the feature. Multiple features should be submitted on multiple branches. Experts may feel free to use command-line Git but are discouraged from rebasing unless absolutely necessary. Any pull requests that would cause conflicts with \texttt{develop} or fail unit tests will be rejected.

\renewcommand{\bibname}{References}
\bibliographystyle{ieeetr}
\bibliography{Semanteco}
\end{document}